{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import type {ContextResponseJson, Status, StatusQuery} from \"./MastodonApiV1.ts\";\n\nconst DataAttributes = ['host', 'status', 'statusUrl', 'include', 'exclude', 'max',  'hideRootStatus', 'display'] as const;\ntype RootDataAttribute = NonNullable<(typeof DataAttributes)[number]>;\n\ntype RootElementDataAttributes = Partial<Record<RootDataAttribute, string>>;\n\nconst fetchJson = async <T>(...args: Parameters<typeof fetch>): Promise<T> => {\n    const response = await fetch(...args);\n    if (!response.ok) {\n        throw new Error(response.statusText);\n    }\n    return await response.json() as T\n}\n\nconst fetchContext = ({host, status}: StatusQuery) =>\n  fetchJson<ContextResponseJson>(`https://${host}/api/v1/statuses/${status}/context?limit=1`, {});\n\nconst fetchStatus = async ({host, status}: StatusQuery) =>\n  fetchJson<Status>(`https://${host}/api/v1/statuses/${status}, {});`);\n\n// Should take query of the form:\n// https://mastodon.social/@MildlyAggrievedScientist/110826278791052494\n// So that users can just paste URLs\nconst urlToStatusQuery = (statusUrl: string): StatusQuery => {\n const {host, pathname} = new URL(statusUrl);\n const status = pathname.split('/')[2] ?? \"\";//.filter( s => s.length > 0 && !s.startsWith('@') );\n return {host, status}\n}\n\nconst fetchStatusAndReplies= async (statusQuery: StatusQuery | string) => {\n const query = (typeof statusQuery === \"string\") ? urlToStatusQuery(statusQuery) : statusQuery; \n const [status, context] = await Promise.all([fetchStatus(query), fetchContext(query)]);\n return [status, ...context.descendants];\n}\n\nconst eventTargetToDataElement = (target: EventTarget | null, dataElement: string): string | undefined => {\n  var value: string | undefined;\n  while (value == null && target instanceof Element) {\n    if (target instanceof HTMLElement) {\n      value = target.dataset[dataElement];\n      if (value != null) {\n        return value;\n      }\n    }\n    target = target.parentElement;\n  }\n}\nexport const eventTargetToResponseUrl = (target: EventTarget | null): string | undefined =>\n  eventTargetToDataElement(target, \"responseUrl\");\nexport const eventTargetToRootCommentUrl = (target: EventTarget | null): string | undefined =>\n  eventTargetToDataElement(target, \"rootCommentUrl\");\n\n/**\n * \n * @param rootCommentElement \n * @returns \n * \n * Uses node.clone to create each comment, so inline event listeners on those comments (onclick=\"...\") will be copied,\n * but event listeners added via addEventListener() will not.  One could add those after the fact by querying all\n * the comments. \n */\nconst loadCommentsIntoDom = async (rootCommentElement: HTMLElement) => {\n  // extra data from data attributes\n  const dataAttributes = ((rootCommentElement as HTMLElement)?.dataset ?? {}) as RootElementDataAttributes;\n  const includeSet = new Set<string>((dataAttributes.include ?? \"\").split(',').map(e => e.trim()));\n  const excludeSet = new Set<string>((dataAttributes.exclude ?? \"\").split(',').map(e => e.trim()));\n  const maxResponses = parseInt(dataAttributes.max ?? \"\");\n  const statusUrl = dataAttributes[\"statusUrl\"];\n  const {host, status} =  statusUrl != null ? urlToStatusQuery(statusUrl) : dataAttributes;\n\n  // ensure there is at least a host and status, either from data-host/data-status or extracted from data-status-url\n  if (host == null || status == null) return;\n\n  // filter excluded responses out\n  const comments = (await fetchStatusAndReplies({host, status}))\n    .filter( r => !excludeSet.has(r.id) );\n  \n  // filter out responses that exceed length limit (though scrolling is recommended instead)\n  if (!isNaN(maxResponses)) {\n    for (var i = comments.length-1; i > 0 && comments.length > maxResponses; i--) {\n      if (!includeSet.has(comments[i].id)) {\n        comments.splice(i, 1);\n      }\n    }\n  }\n\n  // create a map from each comment status id to the DOM element that will hold\n  // its replies\n  const statusIdToElementContainingItsReplies = new Map<string, Element>();\n\n  // create a DOM template for each response comment by cloning the root comment\n  const responseTemplate = rootCommentElement.cloneNode(true) as typeof rootCommentElement;\n\n  // remove data specified for the root comment from the template\n  for (const dataAttribute of DataAttributes) {\n    delete responseTemplate.dataset[dataAttribute]\n  }\n\n  // loop through all response comments to add them\n  for (const comment of comments) {\n    // clone the template to create the element that will hold this response\n    const commentElement = status === comment.id ? rootCommentElement : responseTemplate.cloneNode(true) as typeof rootCommentElement;\n\n    // isolate the child elements for the comments's author, content, and child replies\n    const authorElement = commentElement.querySelector('[data-response-type=author], .response-author');\n    const authorDisplayNameElement = commentElement.querySelector('[data-response-type=author-name], .response-author-name');\n    const authorFullHandleElement = commentElement.querySelector('[data-response-type=author-handle], .response-author-handle');\n    const contentElement = commentElement.querySelector('[data-response-type=content], .response-content');\n    const repliesToThisResponseElement = commentElement.querySelector('[data-response-type=replies], .response-replies');\n    if ((!authorElement && (!authorDisplayNameElement || !authorFullHandleElement)) || !contentElement || !repliesToThisResponseElement) return;\n\n    // create the author content\n    const {account} = comment;\n    const {hostname} = new URL(account.url);\n\n    const authorHandleNameElement = document.createElement('a');\n    authorHandleNameElement.classList.add('fediverse-handle-name');\n    authorHandleNameElement.setAttribute('href', account.url);\n    authorHandleNameElement.setAttribute('target', '_blank');\n    authorHandleNameElement.textContent = `@${account.username}`;\n    \n    const authorHandleHostSpan = document.createElement('span');\n    authorHandleHostSpan.classList.add('fediverse-host-name');\n    authorHandleHostSpan.textContent = `@${hostname}`;\n\n    if (authorDisplayNameElement) {\n      authorDisplayNameElement.textContent = comment.account.display_name;\n    } else if (authorElement) {\n      authorElement.textContent = `${comment.account.display_name} `;\n    }\n    if (authorFullHandleElement) {\n        authorFullHandleElement.appendChild(authorHandleNameElement);\n        authorFullHandleElement.appendChild(authorHandleHostSpan);\n    } else if (authorElement) {\n      authorElement.appendChild(authorHandleNameElement);\n      authorElement.appendChild(authorHandleHostSpan);\n    }\n\n    // copy the content element (non-sanitized, since we're trusting the host server to sanitize it)\n    // if we wanted to sanitize, we could use the [HTML Sanitizer API](https://wicg.github.io/sanitizer-api/),\n    // or [DOMPurify](https://github.com/cure53/DOMPurify/) until there is full browser support for the\n    // the sanitizer API.\n    contentElement.innerHTML = comment.content; // NOT sanitized since I'm trusting server to do so.\n\n    // into each element, we will copy a data attribute that allows event handlers to get the\n    // response's ID and URL.\n    for (const e of [authorElement, authorDisplayNameElement, authorFullHandleElement, contentElement, repliesToThisResponseElement, commentElement]) {\n      if (e != null) {\n        e.setAttribute('data-response-id', comment.id);\n        e.setAttribute('data-response-url', comment.url ?? \"\");\n      }\n    }\n\n    // contentElement.addEventListener('click', (e) => {\n    //   const url = eventTargetToResponseUrl(e.currentTarget);\n    //   if (url) {\n    //     window.location.assign(url);\n    //   }\n    // })\n\n    // set the mapping from this response's status ID to its reply element so that replies\n    // can append themselves to the reply-chain.\n    statusIdToElementContainingItsReplies.set(comment.id, repliesToThisResponseElement);\n    \n    // if (response.id !== status && ) {\n    //   // this response is the root status that belongs in the root comment element.\n    //   rootCommentElement.querySelector('[data-response-type=replies], .response-replies')?.appendChild(responseElement);\n    //   rootCommentElement.setAttribute('data-root-comment-url', response.url ?? \"\");\n    // }\n    if (commentElement !== rootCommentElement && comment.in_reply_to_id) {\n      statusIdToElementContainingItsReplies.get(comment.in_reply_to_id)?.appendChild(commentElement);\n    }\n  }\n}\n\nconst findCommentTemplatesAndLoadCommentsIntoDom = () => {\n  const commentElements = document.querySelectorAll('[data-host][data-status], [data-status-url]');\n  for (const templateElement of commentElements) {\n    if (templateElement instanceof HTMLElement) {\n      loadCommentsIntoDom(templateElement);\n    }\n  }  \n}\n\ndocument.addEventListener('DOMContentLoaded', findCommentTemplatesAndLoadCommentsIntoDom);\n"],
  "mappings": "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",
  "names": ["DataAttributes", "fetchJson", "args", "response", "fetchContext", "host", "status", "fetchStatus", "urlToStatusQuery", "statusUrl", "_a", "pathname", "fetchStatusAndReplies", "statusQuery", "query", "context", "eventTargetToDataElement", "target", "dataElement", "value", "eventTargetToResponseUrl", "eventTargetToRootCommentUrl", "loadCommentsIntoDom", "rootCommentElement", "_b", "_c", "_d", "_e", "_f", "dataAttributes", "includeSet", "e", "excludeSet", "maxResponses", "comments", "r", "i", "statusIdToElementContainingItsReplies", "responseTemplate", "dataAttribute", "comment", "commentElement", "authorElement", "authorDisplayNameElement", "authorFullHandleElement", "contentElement", "repliesToThisResponseElement", "account", "hostname", "authorHandleNameElement", "authorHandleHostSpan", "findCommentTemplatesAndLoadCommentsIntoDom", "commentElements", "templateElement"]
}
